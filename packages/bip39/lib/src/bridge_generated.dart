// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.80.1.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty, unnecessary_const

import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:uuid/uuid.dart';

import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:uuid/uuid.dart';
import 'bridge_generated.io.dart' if (dart.library.html) 'bridge_generated.web.dart';

abstract class Bip39 {
  Future<List<Language>> allStaticMethodLanguage({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAllStaticMethodLanguageConstMeta;

  Future<List<String>> wordListMethodLanguage({required Language that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kWordListMethodLanguageConstMeta;

  Future<List<String>> wordsByPrefixMethodLanguage({required Language that, required String prefix, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kWordsByPrefixMethodLanguageConstMeta;

  Future<int> findWordMethodLanguage({required Language that, required String word, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kFindWordMethodLanguageConstMeta;

  Future<Mnemonic> generateInStaticMethodMnemonic({required Language language, required WordCount wordCount, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGenerateInStaticMethodMnemonicConstMeta;

  Future<Mnemonic> parseStaticMethodMnemonic({required List<String> words, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kParseStaticMethodMnemonicConstMeta;

  Future<Mnemonic> parseInStaticMethodMnemonic({required Language language, required List<String> words, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kParseInStaticMethodMnemonicConstMeta;

  Future<Uint8List> toSeedMethodMnemonic({required Mnemonic that, required String passphrase, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kToSeedMethodMnemonicConstMeta;
}

/// Language to be used for the mnemonic phrase.
enum Language {
  /// The English language.
  English,

  /// The Spanish language.
  Spanish,
}

class Mnemonic {
  final Bip39 bridge;
  final Language language;
  final List<String> words;

  const Mnemonic({
    required this.bridge,
    required this.language,
    required this.words,
  });

  static Future<Mnemonic> generateIn({required Bip39 bridge, required Language language, required WordCount wordCount, dynamic hint}) => bridge.generateInStaticMethodMnemonic(language: language, wordCount: wordCount, hint: hint);

  static Future<Mnemonic> parse({required Bip39 bridge, required List<String> words, dynamic hint}) => bridge.parseStaticMethodMnemonic(words: words, hint: hint);

  static Future<Mnemonic> parseIn({required Bip39 bridge, required Language language, required List<String> words, dynamic hint}) => bridge.parseInStaticMethodMnemonic(language: language, words: words, hint: hint);

  Future<Uint8List> toSeed({required String passphrase, dynamic hint}) => bridge.toSeedMethodMnemonic(
        that: this,
        passphrase: passphrase,
      );
}

/// Type describing entropy length (aka word count) in the mnemonic
enum WordCount {
  /// 12 words mnemonic (128 bits entropy)
  Words12,

  /// 15 words mnemonic (160 bits entropy)
  Words15,

  /// 18 words mnemonic (192 bits entropy)
  Words18,

  /// 21 words mnemonic (224 bits entropy)
  Words21,

  /// 24 words mnemonic (256 bits entropy)
  Words24,
}

class Bip39Impl implements Bip39 {
  final Bip39Platform _platform;
  factory Bip39Impl(ExternalLibrary dylib) => Bip39Impl.raw(Bip39Platform(dylib));

  /// Only valid on web/WASM platforms.
  factory Bip39Impl.wasm(FutureOr<WasmModule> module) => Bip39Impl(module as ExternalLibrary);
  Bip39Impl.raw(this._platform);
  Future<List<Language>> allStaticMethodLanguage({dynamic hint}) {
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_all__static_method__Language(port_),
      parseSuccessData: _wire2api_list_language,
      constMeta: kAllStaticMethodLanguageConstMeta,
      argValues: [],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAllStaticMethodLanguageConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "all__static_method__Language",
        argNames: [],
      );

  Future<List<String>> wordListMethodLanguage({required Language that, dynamic hint}) {
    var arg0 = api2wire_language(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_word_list__method__Language(port_, arg0),
      parseSuccessData: _wire2api_StringList,
      constMeta: kWordListMethodLanguageConstMeta,
      argValues: [
        that
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kWordListMethodLanguageConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "word_list__method__Language",
        argNames: [
          "that"
        ],
      );

  Future<List<String>> wordsByPrefixMethodLanguage({required Language that, required String prefix, dynamic hint}) {
    var arg0 = api2wire_language(that);
    var arg1 = _platform.api2wire_String(prefix);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_words_by_prefix__method__Language(port_, arg0, arg1),
      parseSuccessData: _wire2api_StringList,
      constMeta: kWordsByPrefixMethodLanguageConstMeta,
      argValues: [
        that,
        prefix
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kWordsByPrefixMethodLanguageConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "words_by_prefix__method__Language",
        argNames: [
          "that",
          "prefix"
        ],
      );

  Future<int> findWordMethodLanguage({required Language that, required String word, dynamic hint}) {
    var arg0 = api2wire_language(that);
    var arg1 = _platform.api2wire_String(word);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_find_word__method__Language(port_, arg0, arg1),
      parseSuccessData: _wire2api_i32,
      constMeta: kFindWordMethodLanguageConstMeta,
      argValues: [
        that,
        word
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kFindWordMethodLanguageConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "find_word__method__Language",
        argNames: [
          "that",
          "word"
        ],
      );

  Future<Mnemonic> generateInStaticMethodMnemonic({required Language language, required WordCount wordCount, dynamic hint}) {
    var arg0 = api2wire_language(language);
    var arg1 = api2wire_word_count(wordCount);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_generate_in__static_method__Mnemonic(port_, arg0, arg1),
      parseSuccessData: (d) => _wire2api_mnemonic(d),
      constMeta: kGenerateInStaticMethodMnemonicConstMeta,
      argValues: [
        language,
        wordCount
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGenerateInStaticMethodMnemonicConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "generate_in__static_method__Mnemonic",
        argNames: [
          "language",
          "wordCount"
        ],
      );

  Future<Mnemonic> parseStaticMethodMnemonic({required List<String> words, dynamic hint}) {
    var arg0 = _platform.api2wire_StringList(words);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_parse__static_method__Mnemonic(port_, arg0),
      parseSuccessData: (d) => _wire2api_mnemonic(d),
      constMeta: kParseStaticMethodMnemonicConstMeta,
      argValues: [
        words
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kParseStaticMethodMnemonicConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "parse__static_method__Mnemonic",
        argNames: [
          "words"
        ],
      );

  Future<Mnemonic> parseInStaticMethodMnemonic({required Language language, required List<String> words, dynamic hint}) {
    var arg0 = api2wire_language(language);
    var arg1 = _platform.api2wire_StringList(words);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_parse_in__static_method__Mnemonic(port_, arg0, arg1),
      parseSuccessData: (d) => _wire2api_mnemonic(d),
      constMeta: kParseInStaticMethodMnemonicConstMeta,
      argValues: [
        language,
        words
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kParseInStaticMethodMnemonicConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "parse_in__static_method__Mnemonic",
        argNames: [
          "language",
          "words"
        ],
      );

  Future<Uint8List> toSeedMethodMnemonic({required Mnemonic that, required String passphrase, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_mnemonic(that);
    var arg1 = _platform.api2wire_String(passphrase);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_to_seed__method__Mnemonic(port_, arg0, arg1),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kToSeedMethodMnemonicConstMeta,
      argValues: [
        that,
        passphrase
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kToSeedMethodMnemonicConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "to_seed__method__Mnemonic",
        argNames: [
          "that",
          "passphrase"
        ],
      );

  void dispose() {
    _platform.dispose();
  }
// Section: wire2api

  String _wire2api_String(dynamic raw) {
    return raw as String;
  }

  List<String> _wire2api_StringList(dynamic raw) {
    return (raw as List<dynamic>).cast<String>();
  }

  int _wire2api_i32(dynamic raw) {
    return raw as int;
  }

  Language _wire2api_language(dynamic raw) {
    return Language.values[raw as int];
  }

  List<Language> _wire2api_list_language(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_language).toList();
  }

  Mnemonic _wire2api_mnemonic(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Mnemonic(
      bridge: this,
      language: _wire2api_language(arr[0]),
      words: _wire2api_StringList(arr[1]),
    );
  }

  int _wire2api_u8(dynamic raw) {
    return raw as int;
  }

  Uint8List _wire2api_uint_8_list(dynamic raw) {
    return raw as Uint8List;
  }
}

// Section: api2wire

@protected
int api2wire_i32(int raw) {
  return raw;
}

@protected
int api2wire_language(Language raw) {
  return api2wire_i32(raw.index);
}

@protected
int api2wire_u8(int raw) {
  return raw;
}

@protected
int api2wire_word_count(WordCount raw) {
  return api2wire_i32(raw.index);
}
// Section: finalizer
